
""" Events for gtk.Windows of various types, including dialogs """

from baseevents import SignalEvent
import gtk, types

class DeletionEvent(SignalEvent):
    signalName = "delete-event"
    def getEmissionArgs(self, argumentString):
        return [ gtk.gdk.Event(gtk.gdk.DELETE) ]
            
    def generate(self, argumentString):
        SignalEvent.generate(self, argumentString)
        self.widget.destroy() # just in case...


class DialogEventHandler:      
    def hasUsecaseName(self):
        return not self.name.startswith("Auto.")

    def hasWidgetName(self):
        return "Name=" in self.name

    def superfluousAutoGenerated(self):
        if self.hasUsecaseName():
            return False
        hasWidgetName = self.hasWidgetName() 
        for event, handler, args in self.dialogInfo.get(self.widget):
            if event and (event.hasUsecaseName() or (not hasWidgetName and event.hasWidgetName())):
                return True
        return False

    def connectRecord(self, method):
        handler = self._connectRecord(self.widget, method)
        self.storeHandler(self.widget, handler, self)

    @classmethod
    def storeHandler(cls, widget, handler, event=None, args=()):
        # Dialogs get handled in a special way which leaves them open to duplication...
        cls.dialogInfo.setdefault(widget, []).append((event, handler, args))


class ResponseEvent(DialogEventHandler, SignalEvent):
    signalName = "response"
    dialogInfo = {}
    def __init__(self, name, widget, responseId):
        SignalEvent.__init__(self, name, widget)
        self.responseId = self.parseId(responseId)
            
    def shouldRecord(self, widget, responseId, *args):
        return self.responseId == responseId and \
            SignalEvent.shouldRecord(self, widget, responseId, *args) and \
            not self.superfluousAutoGenerated()

    @classmethod
    def getAssociatedSignatures(cls, widget):
        names = filter(lambda x: x.startswith("RESPONSE_"), dir(gtk))
        return set((name.lower().replace("_", ".", 1) for name in names))

    def getProgrammaticChangeMethods(self):
        return [ self.widget.response ]

    def getUiMapSignature(self):
        return self.getRecordSignal() + "." + self.getResponseIdSignature()

    def getResponseIdSignature(self):
        return repr(self.responseId).split()[1].split("_")[-1].lower()

    def getEmissionArgs(self, argumentString):
        return [ self.responseId ]

    def parseId(self, responseId):
        # May have to reverse the procedure in getResponseIdSignature
        if type(responseId) == types.StringType:
            return eval("gtk.RESPONSE_" + responseId.upper())
        else:
            return responseId

